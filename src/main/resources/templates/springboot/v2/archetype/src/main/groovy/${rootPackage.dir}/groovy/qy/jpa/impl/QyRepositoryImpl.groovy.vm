package ${rootPackage.name}.groovy.qy.jpa.impl

import static ${rootPackage.name}.groovy.qy.QyAggregable.Operation.COUNT

import javax.annotation.PostConstruct
import javax.persistence.EntityManager
import javax.persistence.PersistenceContext
import javax.persistence.TypedQuery
import javax.persistence.criteria.CriteriaBuilder
import javax.persistence.criteria.CriteriaQuery
import javax.persistence.criteria.Root

import org.springframework.data.domain.Page
import org.springframework.data.domain.PageImpl
import org.springframework.data.domain.Pageable
import org.springframework.data.jpa.domain.Specification
import org.springframework.stereotype.Repository
import org.springframework.transaction.annotation.Transactional

import ${rootPackage.name}.groovy.qy.QyAggregable
import ${rootPackage.name}.groovy.qy.QyAggregation
import ${rootPackage.name}.groovy.qy.QyPage
import ${rootPackage.name}.groovy.qy.QyPayload
import ${rootPackage.name}.groovy.qy.QyProjectable
import ${rootPackage.name}.groovy.qy.QySpecification
import ${rootPackage.name}.groovy.qy.jpa.QyRepository
import groovy.util.logging.Slf4j

@Slf4j
@Repository
@Transactional(readOnly = true)
class QyRepositoryImpl<T> implements QyRepository<T>{

	@PersistenceContext
	EntityManager entityManager

	Map operations = [:]

	@Autowired
	private ApplicationContext applicationContext

	@PostConstruct
	protected void init() {
		operations[QyAggregable.Operation.COUNT] = { dataField, Root<T> root, CriteriaBuilder cb -> cb.count(root.get(dataField)) }
		operations[QyAggregable.Operation.SUM]   = { dataField, Root<T> root, CriteriaBuilder cb -> cb.sum(root.get(dataField)) }
		operations[QyAggregable.Operation.MIN]   = { dataField, Root<T> root, CriteriaBuilder cb -> cb.min(root.get(dataField)) }
		operations[QyAggregable.Operation.MAX]   = { dataField, Root<T> root, CriteriaBuilder cb -> cb.max(root.get(dataField)) }
		operations[QyAggregable.Operation.AVG]   = { dataField, Root<T> root, CriteriaBuilder cb -> cb.avg(root.get(dataField)) }
	}

	@Override
	public QyPage<T> findAll(Class<T> entityClass, Pageable pageable, QyProjectable projectable, Class<? extends QySpecification<T>> specificationClass, QyPayload payload) {
		CriteriaBuilder cb = entityManager.criteriaBuilder
		def cq = projectable?.fields ? cb.createQuery(Object[].class) : cb.createQuery(entityClass)
		Root<T> root = cq.from(entityClass)
		if(projectable?.fields) cq.select(cb.array(projectable.fields.collect { root.get(it) }))
		Specification<T> spec = getSpecification(entityClass, specificationClass, payload)
		this.prepareWhereDecl(root, cq, cb, spec)
		this.prepareOrderByDecl(root, cq, cb, pageable, specificationClass)
		TypedQuery<T> q = this.createQuery(cq, pageable)
		QyAggregation countAggregation = this.aggregationTemplate(entityClass, "id", spec, COUNT)

		List<T> results = !projectable?.fields ? q.resultList : q.resultList.collect {
			T entity = entityClass.getDeclaredConstructor().newInstance()
			projectable.fields.eachWithIndex { field, idx -> entity[field] = it[idx] }
			return entity
		}

		Page<T> page = new PageImpl(results, pageable, countAggregation.result as Long)
		if(payload?.aggregables) return new QyPage(pagination: page, aggregations: aggregation(entityClass, spec, payload?.aggregables))
		return new QyPage(pagination: page)
	}

	public List<QyAggregation> aggregation(Class<T> entityClass, Specification<T> specification, QyAggregable... aggregragables) {
		aggregragables.collect { aggregationTemplate(entityClass, it.dataField, specification, it.operation) }
	}

	/*
	 * Retorna a Specification associadas a entidade T. O retorna é a união entre os predicados da specification fixa (fixedSpecification) juntamente com os predicados das 
	 * specification variável (variableSpecification).
	 */
	private Specification<T> getSpecification(Class<T> entityClass, Class<? extends QySpecification<T>> specificationClass, QyPayload payload) {
		if(payload?.filterable) {
			QySpecification<T>  specification = applicationContext.getBean(specificationClass)
			Specification<T> finalSpec = specification.fixedSpecification().and(specification.variableSpecification(entityClass, payload.filterable))
		}
	}

	/*
	 * Prepara a cláusula Where da consulta.
	 */
	private void prepareWhereDecl(Root<T> root, CriteriaQuery<T> cq, CriteriaBuilder cb, Specification<T> spec) {
		if(spec && spec.toPredicate(root, cq, cb)) cq.where(spec.toPredicate(root, cq, cb))
	}

	/*
	 * Prepara a cláusua Order By da consulta.
	 */
	private void prepareOrderByDecl(Root<T> root, CriteriaQuery<T> cq, CriteriaBuilder cb,Pageable pageable, Class<? extends QySpecification<T>> specificationClass) {
		QySpecification<T>  specification = applicationContext.getBean(specificationClass)
		if(pageable?.sort) cq.orderBy(pageable.sort.orders.collect {
			QyAttributePath qyAttr = specification.paths.get(it.property)
			Path path = qyAttr ? qyAttr.map.apply(root): root.get(it.property)
			it.ascending ? cb.asc(path) : cb.desc(path)
		})
	}

	private TypedQuery<T> createQuery(CriteriaQuery<T> cq, Pageable pageable) {
		TypedQuery<T> q = entityManager.createQuery(cq)
		if(pageable) {
			q.setFirstResult(pageable.getPageNumber() * pageable.getPageSize())
			q.setMaxResults(pageable.getPageSize())
		}
		return q
	}

	/**
	 * Template para execução de operação de agregação
	 * 
	 * @param entityClass
	 * @param dataField
	 * @param spec
	 * @param operation
	 * @return
	 */
	private QyAggregation aggregationTemplate(Class<T> entityClass, String dataField, Specification<T> spec, QyAggregable.Operation operation) {
		CriteriaBuilder cb = entityManager.criteriaBuilder
		CriteriaQuery<T> cq = cb.createQuery(entityClass)
		Root<T> root = cq.from(entityClass)
		cq.select(operations[operation](dataField, root, cb))
		if(spec && spec.toPredicate(root, cq, cb)) cq.where(spec.toPredicate(root, cq, cb))
		TypedQuery query = entityManager.createQuery(cq)
		return new QyAggregation(dataField: dataField, result: query.getSingleResult(), operation: operation)
	}
}
