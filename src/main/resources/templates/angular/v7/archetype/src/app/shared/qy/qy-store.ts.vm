#set ($OB = "${")
#set ($CB = "}")
import { EventEmitter } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { LoadOptions } from 'devextreme/data/load_options';
import CustomStore from 'devextreme/data/custom_store';

import { QyStoreOptions } from './qy-store-options';
import { QyAggregation } from './qy-aggregation';
import { QyFilterable } from './filter/qy-filterable';
import { environment } from '../../../environments/environment';
import { QyPayload } from './qy-payload';
import { QyFilter } from './filter/qy-filter';
import { QyPage } from './qy-page';
import { Page } from '../page';

/**
 * Store para ser usado nos DataSouces que deve receber no seu construtor:
 * 
 * - http: HttpClient (usado para fazer as requisições ao servidor)
 * - basePath: string (raíz dos endpoints rest onde os requests serão feitos)
 * - options: QyStoreOptions (configurações específicas dos requests)
 * 
 * Apenas options é opcional
 * 
 * ---
 * Atributos
 * 
 * - onLoad: EventEmitter (é emitido ao final do load, quando as variáveis do Store são atualizados)
 * - sortParams: string (parâmetros de ordenação usados no request do último load)
 * - filter: QyFilterable (filtro usado no request do último load)
 * - aggregations: QyAggregation[] (agregações resultadas do último load)
 * 
 * ---
 * Métodos
 * 
 * - getSummary(dataField?, operation?): QyAggregation[] (retorna as agregações resultadas do último load com filtros opcionais)
 * 
 */
export class QyStore<T> extends CustomStore {

  /** EventEmitter emitido ao final do load, quando as variáveis do Store são atualizados */
  onLoad: EventEmitter<any> = new EventEmitter<any>();

  /** Parâmetros de ordenação usados no request do último load do Store */
  sortParams: string;
  /** Filtro usado no request do último load do Store */
  filter: QyFilterable;
  /** Agregações resultadas do último load do Store */
  aggregations: QyAggregation[];

  constructor(
    /** Usado para fazer as requisições ao servidor, e deve ser uma depenência injetada do Componente que instanciar o Store */
    http: HttpClient,
    /** Caminho raíz dos endpoints rest onde os requests serão feitos pelo Store */
    basePath: string,
    /** QyStoreOptions contendo configurações específicas dos requests que serão feitos pelo Store */
    options: QyStoreOptions = new QyStoreOptions()
  ) {
    super({
      key: options.key === undefined ? 'id' : options.key,
      byKey: (key) => {
        if (options.key === null) return key;
        return http.get<T>(this.byKeyUrl(options, basePath, key)).toPromise();
      },
      load: (loadOptions: LoadOptions) => {
        if (options.loadByGet) return http.get<Page<T>>(this.loadUrl(loadOptions, options, basePath))
          .toPromise()
          .finally(() => this.updateStoreVariables(loadOptions))
          .then((page: Page<T>) => ({
            data: page.content,
            totalCount: page.totalElements
          }));

        return http.post<QyPage<T>>(this.loadUrl(loadOptions, options, basePath), this.payloadFromLoadOptions(loadOptions))
          .toPromise()
          .then((qyPage: QyPage<T>) => {
            this.updateStoreVariables(loadOptions, qyPage.aggregations);
            return qyPage;
          })
          .then((qyPage: QyPage<T>) => ({
            data: qyPage.pagination ? qyPage.pagination.content : undefined,
            totalCount: qyPage.pagination ? qyPage.pagination.totalElements : undefined,
            summary: qyPage.aggregations ? qyPage.aggregations.map(agg => agg.result) : undefined
          }));
      }
    });
  }

  /**
   * Retorna a string referente a URL que deve ser usada para o request do byKey (findOne)
   * 
   * @param options
   * @param basePath
   * @param key
   */
  private byKeyUrl(options: QyStoreOptions, basePath: string, key: any): string {
    return `${OB}environment.urlbase${CB}${OB}options.endpoints.byKey || basePath${CB}/${OB}key${CB}`;
  }

  /**
   * Retorna a string referente a URL que deve ser usada para o request do load (findAll)
   * 
   * @param loadOptions 
   * @param options 
   * @param basePath 
   */
  private loadUrl(loadOptions: LoadOptions, options: QyStoreOptions, basePath: string): string {
    let params = this.paramsFromLoadOptions(loadOptions);
    if (options.loadByGet) return `${OB}environment.urlbase${CB}${OB}options.endpoints.load || basePath${CB}${OB}params${CB}`;
    return `${OB}environment.urlbase${CB}${OB}options.endpoints.load || `${OB}basePath${CB}/all`${CB}${OB}params${CB}`;
  }

  /**
   * Retorna a string referente aos parâmetros que devem ser usado no request do load (findAll)
   * 
   * @param loadOptions 
   */
  private paramsFromLoadOptions(loadOptions: LoadOptions): string {
    let skip = loadOptions.skip,
      take = loadOptions.take,
      page = skip ? (skip / take) : 0,
      params = `?page=${OB}page${CB}&size=${OB}take${CB}`;
    if (loadOptions.sort) params += `&${OB}this.paramFromSort(loadOptions.sort)${CB}`;
    if (loadOptions.select) params += `&fields=${OB}loadOptions.select.join(',')${CB}`;
    return params;
  }

  /**
   * Retorna o payload referente ao body que deve ser usado no request do load (findAll)
   * 
   * @param loadOptions 
   */
  private payloadFromLoadOptions(loadOptions: LoadOptions): QyPayload {
    return {
      filterable: this.filterableFromLoadOptions(loadOptions),
      aggregables: loadOptions.totalSummary
    };
  }

  /**
   * Retorna um filterable referente ao filtro que deve ser usado na formação de um payload
   * 
   * @param loadOptions
   */
  private filterableFromLoadOptions(loadOptions: LoadOptions): QyFilterable {
    let searchExpr = loadOptions.searchExpr as string | string[],
      searchOperation = loadOptions.searchOperation as '=' | '<>' | '>' | '>=' | '<' | '<=' | 'startswith' | 'endswith' | 'contains' | 'notcontains' | 'isblank' | 'isnotblank',
      searchValue = loadOptions.searchValue,
      filter = loadOptions.filter;
    if (!filter && !searchExpr) return undefined;
    return QyFilter.of(filter).add(searchExpr, searchOperation, searchValue).qyFilterable;
  }

  /**
   * Retorna a string referente ao parâmetro de ordenação
   * 
   * @param sort
   */
  private paramFromSort(sort: { selector: string, desc: boolean }[]): string {
    return sort.map(order => `sort=${OB}order.selector${CB},${OB}order.desc ? 'desc' : 'asc'${CB}`).join('&');
  }

  /**
   * Atualiza as variáveis do Store
   * 
   * @param loadOptions 
   * @param aggregations
   */
  private updateStoreVariables(loadOptions: LoadOptions, aggregations?: QyAggregation[]): void {
    this.sortParams = loadOptions.sort ? this.paramFromSort(loadOptions.sort) : null;
    this.filter = loadOptions.filter ? QyFilter.of(loadOptions.filter).qyFilterable : null;
    if (loadOptions.totalSummary) this.aggregations = aggregations;
    this.onLoad.emit();
  }

  /**
   * Método que retorna as agregações resultadas do último load do Store com filtros opcionais
   * 
   * @param dataField
   * @param operation
   */
  getSummary(dataField?: string, operation?: 'count' | 'sum' | 'max' | 'min' | 'avg'): QyAggregation[] {
    let filteredSummary: QyAggregation[];
    if (!dataField) return this.aggregations;
    if (operation) filteredSummary = this.aggregations
      .filter(agg => agg.dataField === dataField && agg.operation === operation);
    else filteredSummary = this.aggregations
      .filter(agg => agg.dataField === dataField);
    if (filteredSummary.length === 0) return null;
    return filteredSummary;
  }

}